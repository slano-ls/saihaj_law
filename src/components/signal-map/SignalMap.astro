---
import type { SignalStar } from "@/stores/signalStore";
import { generateInitialSignals } from "@/utils/signalUtils";
import { starVertexShader, starFragmentShader, shootingStarVertexShader, shootingStarFragmentShader } from "@/shaders/starShader";
---

<div class="relative h-full w-full">
    <canvas id="signal-canvas" class="absolute inset-0" />
    
    <!-- Minimal UI Elements -->
    <div class="absolute top-4 left-4 z-10 text-white/50 font-light text-sm">
        Neural Network
    </div>
    
    <div class="absolute bottom-4 right-4 z-10 flex flex-col items-end gap-2">
        <div class="flex items-center gap-2 text-white/50 text-sm">
            <span>Activity</span>
            <div class="flex items-center gap-1">
                <span class="text-xs">•</span>
                <span class="text-xs">•</span>
                <span class="text-xs">•</span>
            </div>
        </div>
        <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value="0.5"
            class="w-32 accent-white/50"
            id="threshold-slider"
        />
    </div>

    <!-- Tooltip -->
    <div id="signal-tooltip" class="absolute pointer-events-none opacity-0 transition-opacity duration-200 text-white/80 text-sm font-light max-w-xs p-4 bg-black/50 backdrop-blur-sm rounded">
        <p id="signal-message"></p>
    </div>
</div>

<script>
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
    import { generateInitialSignals } from "@/utils/signalUtils";
    import { useSignalStore } from "@/stores/signalStore";
    import { starVertexShader, starFragmentShader, shootingStarVertexShader, shootingStarFragmentShader } from "@/shaders/starShader";

    // Initialize Three.js scene
    const canvas = document.getElementById("signal-canvas") as HTMLCanvasElement;
    if (!canvas) throw new Error("Canvas element not found");

    const renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    // Enhanced controls with zoom constraints
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 20;
    controls.maxDistance = 100;
    controls.maxPolarAngle = Math.PI / 2;

    // Create neural network structure
    const signals = generateInitialSignals(30); // Reduced number of neurons for better visibility
    const positions = new Float32Array(signals.flatMap(s => s.position));
    const brightnesses = new Float32Array(signals.map(s => s.brightness));
    const sizes = new Float32Array(signals.map(() => 3)); // Larger neuron size

    // Create neuron points with custom shader
    const neuronGeometry = new THREE.BufferGeometry();
    const neuronMaterial = new THREE.ShaderMaterial({
        vertexShader: starVertexShader,
        fragmentShader: starFragmentShader,
        uniforms: {
            time: { value: 0 }
        },
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    neuronGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    neuronGeometry.setAttribute('brightness', new THREE.BufferAttribute(brightnesses, 1));
    neuronGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const neuronPoints = new THREE.Points(neuronGeometry, neuronMaterial);
    scene.add(neuronPoints);

    // Create synaptic connections
    const synapseGeometry = new THREE.BufferGeometry();
    const synapseMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
    });

    const synapses: { 
        start: number; 
        end: number; 
        progress: number; 
        speed: number;
        pulse: number;
        active: boolean;
    }[] = [];
    const synapsePositions = new Float32Array(100 * 6); // Max 100 synapses
    const synapseProgress = new Float32Array(100);

    synapseGeometry.setAttribute('position', new THREE.BufferAttribute(synapsePositions, 3));
    const synapseLines = new THREE.LineSegments(synapseGeometry, synapseMaterial);
    scene.add(synapseLines);

    // Function to create a new synapse
    function createSynapse() {
        if (synapses.length >= 100) return;

        const startIndex = Math.floor(Math.random() * signals.length);
        const endIndex = Math.floor(Math.random() * signals.length);
        
        if (startIndex === endIndex) return;

        synapses.push({
            start: startIndex,
            end: endIndex,
            progress: 0,
            speed: Math.random() * 0.01 + 0.005,
            pulse: 0,
            active: false
        });

        // Update geometry
        const index = synapses.length - 1;
        const startPos = signals[startIndex].position;
        const endPos = signals[endIndex].position;
        
        synapsePositions[index * 6] = startPos[0];
        synapsePositions[index * 6 + 1] = startPos[1];
        synapsePositions[index * 6 + 2] = startPos[2];
        synapsePositions[index * 6 + 3] = startPos[0];
        synapsePositions[index * 6 + 4] = startPos[1];
        synapsePositions[index * 6 + 5] = startPos[2];
        
        synapseProgress[index] = 0;
    }

    // Raycaster for hover detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredNeuron: number | null = null;

    // Handle mouse movement
    canvas.addEventListener('mousemove', (event: MouseEvent) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update tooltip position
        const tooltip = document.getElementById('signal-tooltip');
        if (tooltip) {
            tooltip.style.left = `${event.clientX}px`;
            tooltip.style.top = `${event.clientY}px`;
        }
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        // Update time uniform for shaders
        const time = Date.now() * 0.001;
        neuronMaterial.uniforms.time.value = time;
        
        // Update neuron positions and brightness
        const positionAttribute = neuronGeometry.getAttribute('position');
        const brightnessAttribute = neuronGeometry.getAttribute('brightness');
        
        if (!positionAttribute || !brightnessAttribute) {
            console.error('Required geometry attributes not found');
            return;
        }

        const positions = positionAttribute.array as Float32Array;
        const brightnesses = brightnessAttribute.array as Float32Array;
        
        // Raycast for hover detection
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(neuronPoints);
        
        if (intersects.length > 0) {
            const index = intersects[0].index;
            if (index !== undefined) {
                hoveredNeuron = index;
                
                // Update tooltip
                const tooltip = document.getElementById('signal-tooltip');
                const message = document.getElementById('signal-message');
                if (tooltip && message) {
                    tooltip.style.opacity = '1';
                    message.textContent = signals[index].message || '';
                }
            }
        } else {
            hoveredNeuron = null;
            const tooltip = document.getElementById('signal-tooltip');
            if (tooltip) {
                tooltip.style.opacity = '0';
            }
        }
        
        // Update synapses
        for (let i = synapses.length - 1; i >= 0; i--) {
            const synapse = synapses[i];
            
            // Randomly activate synapses
            if (!synapse.active && Math.random() < 0.001) {
                synapse.active = true;
                synapse.progress = 0;
                synapse.pulse = 0;
            }
            
            if (synapse.active) {
                synapse.progress += synapse.speed;
                synapse.pulse = Math.sin(synapse.progress * Math.PI * 2) * 0.5 + 0.5;
                
                if (synapse.progress >= 1) {
                    synapse.active = false;
                } else {
                    const startPos = signals[synapse.start].position;
                    const endPos = signals[synapse.end].position;
                    
                    // Calculate current position along the synapse
                    const currentX = startPos[0] + (endPos[0] - startPos[0]) * synapse.progress;
                    const currentY = startPos[1] + (endPos[1] - startPos[1]) * synapse.progress;
                    const currentZ = startPos[2] + (endPos[2] - startPos[2]) * synapse.progress;
                    
                    // Update synapse line with pulse effect
                    synapsePositions[i * 6] = startPos[0];
                    synapsePositions[i * 6 + 1] = startPos[1];
                    synapsePositions[i * 6 + 2] = startPos[2];
                    synapsePositions[i * 6 + 3] = currentX;
                    synapsePositions[i * 6 + 4] = currentY;
                    synapsePositions[i * 6 + 5] = currentZ;
                    
                    // Update synapse opacity based on pulse
                    synapseMaterial.opacity = 0.3 + synapse.pulse * 0.3;
                }
            }
        }
        
        // Randomly create new synapses
        if (Math.random() < 0.01) {
            createSynapse();
        }
        
        positionAttribute.needsUpdate = true;
        brightnessAttribute.needsUpdate = true;
        synapseGeometry.attributes.position.needsUpdate = true;
        
        renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Handle threshold slider
    const thresholdSlider = document.getElementById("threshold-slider") as HTMLInputElement;
    if (thresholdSlider) {
        thresholdSlider.addEventListener("input", (e) => {
            const target = e.target as HTMLInputElement;
            const threshold = parseFloat(target.value);
            neuronMaterial.uniforms.opacity = { value: threshold };
        });
    }
</script> 